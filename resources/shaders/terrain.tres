[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;


uniform int max_altitude = 1;

uniform float steepness = 0.55;

uniform sampler2D heightmap;
uniform sampler2D normalmap;

uniform sampler2D antitile_noise;
uniform sampler2D ab_noise;

uniform vec2 texture0a_scale = vec2(1.0);
uniform sampler2D texture0a_diffuse;
uniform sampler2D texture0a_normal;
uniform sampler2D texture0a_roughness;
uniform sampler2D texture0a_ao;

uniform vec2 texture0b_scale = vec2(1.0);
uniform sampler2D texture0b_diffuse;
uniform sampler2D texture0b_normal;
uniform sampler2D texture0b_roughness;
uniform sampler2D texture0b_ao;

uniform vec2 texture1a_scale = vec2(1.0);
uniform sampler2D texture1a_diffuse;
uniform sampler2D texture1a_normal;
uniform sampler2D texture1a_roughness;
uniform sampler2D texture1a_ao;

uniform vec2 texture1b_scale = vec2(1.0);
uniform sampler2D texture1b_diffuse;
uniform sampler2D texture1b_normal;
uniform sampler2D texture1b_roughness;
uniform sampler2D texture1b_ao;



float sum_vec3(vec3 v) {
	return v.x + v.y + v.z;
}


vec3 texture_antitile(sampler2D p_sampler, in vec2 x) {
	float k = texture(antitile_noise, 0.005*x).x; // cheap (cache friendly) lookup
    
	float index = k * 8.0;
	float i = floor(index);
	float f = fract(index);
	
	vec2 offa = sin(vec2(3.0,7.0)*(i+0.0)); // can replace with any other hash
	vec2 offb = sin(vec2(3.0,7.0)*(i+1.0)); // can replace with any other hash
	
	vec3 cola = texture(p_sampler, x + offa).xyz;
	vec3 colb = texture(p_sampler, x + offb).xyz;
    
	return mix(cola, colb, smoothstep(0.2, 0.8, f - 0.1 * sum_vec3(cola-colb)));
}


void vertex() {
	float height = texture(heightmap, UV).a;
	VERTEX.y = height * float(max_altitude);
}


vec3 get_albedo(float slope, vec2 uv) {
	vec3 albedo = vec3(0.0); 
	
	vec3 texture0a = texture_antitile(texture0a_diffuse, uv * texture0a_scale).rgb;
	vec3 texture0b = texture_antitile(texture0b_diffuse, uv * texture0b_scale).rgb;
	vec3 texture1a = texture_antitile(texture1a_diffuse, uv * texture1a_scale).rgb;
	vec3 texture1b = texture_antitile(texture1b_diffuse, uv * texture1b_scale).rgb;

	if (slope <= steepness) {
		float blend_amount = slope / steepness;
		albedo = mix(texture0a, texture1a, blend_amount);
	} 
	else {
		albedo = texture1a;
	} 
	
	return albedo.rgb;
}


vec3 get_normal(float slope, vec2 uv) {
	vec3 normal = vec3(0.0); 

	vec3 texture0a = texture_antitile(texture0a_normal, uv * texture0a_scale).rgb;
	vec3 texture0b = texture_antitile(texture0b_normal, uv * texture0b_scale).rgb;
	vec3 texture1a = texture_antitile(texture1a_normal, uv * texture1a_scale).rgb;
	vec3 texture1b = texture_antitile(texture1b_normal, uv * texture1b_scale).rgb;

	if (slope <= steepness) {
		float blend_amount = slope / steepness;
		normal = mix(texture0a, texture1a, blend_amount);
	} 
	else {
		normal = texture1a;
	} 

	return mix(texture(normalmap, uv).rgb, normal, 0.5);
}


float get_roughness(float slope, vec2 uv) {
	float roughness = 0.0;

	float texture0a = texture_antitile(texture0a_roughness, uv * texture0a_scale).r;
	float texture0b = texture_antitile(texture0b_roughness, uv * texture0b_scale).r;
	float texture1a = texture_antitile(texture1a_roughness, uv * texture1a_scale).r;
	float texture1b = texture_antitile(texture1b_roughness, uv * texture1b_scale).r;

	if (slope <= steepness) {
		float blend_amount = slope / steepness;
		roughness = mix(texture0a, texture1a, blend_amount);
	} 
	else {
		roughness = texture1a;
	} 

	return max(roughness, 1.0);
}


float get_ao(float slope, vec2 uv) {
	float ao = 0.0;

	float texture0a = texture_antitile(texture0a_ao, uv * texture0a_scale).r;
	float texture0b = texture_antitile(texture0b_ao, uv * texture0b_scale).r;
	float texture1a = texture_antitile(texture1a_ao, uv * texture1a_scale).r;
	float texture1b = texture_antitile(texture1b_ao, uv * texture1b_scale).r;

	if (slope <= steepness) {
		float blend_amount = slope / steepness;
		ao = mix(texture0a, texture1a, blend_amount);
	} 
	else {
		ao = texture1a;
	} 

	return ao;
}


void fragment() {
	vec3 normal = texture(normalmap, UV).rgb;
	float slope = acos(normal.z);

	ALBEDO = get_albedo(slope, UV);
	NORMALMAP = get_normal(slope, UV);
	NORMALMAP_DEPTH = 2.0;
	ROUGHNESS = get_roughness(slope, UV);
	AO = get_ao(slope, UV);
	AO_LIGHT_AFFECT = 1.0;
}
"
