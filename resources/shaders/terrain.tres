[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode world_vertex_coords;

uniform int max_altitude = 1;
uniform float steepness = 0.55;

uniform sampler2D heightmap;
uniform sampler2D normalmap;

uniform sampler2D antitile_noise;
uniform sampler2D ab0_noise;
uniform sampler2D ab1_noise;

uniform float ab0_half_blend_amount = 0.1;
uniform float ab1_half_blend_amount = 0.1;
uniform float steepness_half_blend_amount = 0.1;
uniform float triplanar_scale = 1.0;

uniform vec2 texture0a_scale = vec2(1.0);
uniform sampler2D texture0a_diffuse;
uniform sampler2D texture0a_normal;
uniform sampler2D texture0a_roughness;
uniform sampler2D texture0a_ao;
//
uniform vec2 texture0b_scale = vec2(1.0);
uniform sampler2D texture0b_diffuse;
uniform sampler2D texture0b_normal;
uniform sampler2D texture0b_roughness;
uniform sampler2D texture0b_ao;
//
uniform vec2 texture1a_scale = vec2(1.0);
uniform sampler2D texture1a_diffuse;
uniform sampler2D texture1a_normal;
uniform sampler2D texture1a_roughness;
uniform sampler2D texture1a_ao;
//
uniform vec2 texture1b_scale = vec2(1.0);
uniform sampler2D texture1b_diffuse;
uniform sampler2D texture1b_normal;
uniform sampler2D texture1b_roughness;
uniform sampler2D texture1b_ao;

varying vec3 uv_triplanar_pos;
varying vec3 uv_power_normal;

uniform float culling_max_distance = 100.0;
varying mat4 mdv_mx;
varying vec3 vtx;


float sum_vec3(vec3 v) {
	return v.x + v.y + v.z;
}


vec3 texture_antitile(sampler2D sampled_texture, in vec2 uv) {
	float noise = texture(antitile_noise, 0.005*uv).x; // cheap (cache friendly) lookup
    
	float index = noise * 8.0;
	float i = floor(index);
	float f = fract(index);
	
	vec2 offa = sin(vec2(3.0,7.0)*(i+0.0)); // can replace with any other hash
	vec2 offb = sin(vec2(3.0,7.0)*(i+1.0)); // can replace with any other hash
	
	vec3 cola = texture(sampled_texture, uv + offa).xyz;
	vec3 colb = texture(sampled_texture, uv + offb).xyz;
    
	return mix(cola, colb, smoothstep(0.2, 0.8, f - 0.1 * sum_vec3(cola-colb)));
}


bool distance_culling() {
	float z_dist = clamp((mdv_mx * vec4(vtx, 1.0)).z * -1.0,0.0, 2000.0 + 10.0);
	float x_dist = (mdv_mx * vec4(vtx, 1.0)).x;
	float dist = sqrt(z_dist * z_dist + x_dist * x_dist);
	if (dist > culling_max_distance || z_dist < 0.0) {
		return true;
	}
	else {
		return false;
	}
}

void vertex() {
	VERTEX.y = texture(heightmap, UV).a * float(max_altitude);
	mdv_mx = MODELVIEW_MATRIX;
	vtx = VERTEX;
	if (distance_culling()) {
		VERTEX = vec3(sqrt(-MODELVIEW_MATRIX[3][3]));
	} 
	else {
		uv_power_normal = pow(abs(mat3(WORLD_MATRIX) * NORMAL), vec3(1.0));
		uv_triplanar_pos = (WORLD_MATRIX * vec4(VERTEX, 1.0f)).xyz * triplanar_scale;
		uv_power_normal /= dot(uv_power_normal, vec3(1.0));
		uv_triplanar_pos *= vec3(1.0, -1.0, 1.0);
	}
}


vec3 triplanar_texture(sampler2D p_sampler, vec2 tex_scale, vec3 p_triplanar_pos, vec3 p_weights) {
	vec3 samp = vec3(0.0);
	samp+= texture_antitile(p_sampler,p_triplanar_pos.xy * tex_scale.x) * p_weights.z;
	samp+= texture_antitile(p_sampler,p_triplanar_pos.xz * tex_scale.xy) * p_weights.y;
	samp+= texture_antitile(p_sampler,p_triplanar_pos.zy * tex_scale.y * vec2(-1.0,1.0)) * p_weights.x;
	return samp;
}


vec3 process_slope_and_mix_vec3(float slope, vec2 uv, sampler2D texture0a, sampler2D texture0b, sampler2D texture1a, sampler2D texture1b) {
	vec3 result = vec3(0.0);
	if (slope < steepness - steepness_half_blend_amount) {
		float ab0_noise_sample = texture(ab0_noise, uv).r;
		if (ab0_noise_sample < 0.5 - ab0_half_blend_amount) {
			result = triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
		else if (ab0_noise_sample < 0.5 + ab0_half_blend_amount) {
			result = mix(
				triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				(ab0_noise_sample - (0.5 - ab0_half_blend_amount)) * (1.0f / ((0.5 + ab0_half_blend_amount) - (0.5 - ab0_half_blend_amount))));
		}
		else {
			result = triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
	}
	
// FLAT-STEEP MIX
	else if (slope < steepness + steepness_half_blend_amount) {
		float blend_amount =  (slope - (steepness - steepness_half_blend_amount)) * (1.0f / ((steepness + steepness_half_blend_amount) - (steepness - steepness_half_blend_amount)));
		float ab0_noise_sample = texture(ab0_noise, uv).r;
		vec3 ab0premix;
		if (ab0_noise_sample < 0.5 - ab0_half_blend_amount) {
			ab0premix = triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
		else if (ab0_noise_sample < 0.5 + ab0_half_blend_amount) {
			ab0premix = mix(
				triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				(ab0_noise_sample - (0.5 - ab0_half_blend_amount)) * (1.0f / ((0.5 + ab0_half_blend_amount) - (0.5 - ab0_half_blend_amount))));
		}
		else {
			ab0premix = triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
		float ab1_noise_sample = texture(ab1_noise, uv).r;
		vec3 ab1premix;
		if (ab1_noise_sample < 0.5 - ab1_half_blend_amount) {
			ab1premix = triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
		else if (ab1_noise_sample < 0.5 + ab1_half_blend_amount) {
			ab1premix = mix(
				triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				(ab1_noise_sample - (0.5 - ab1_half_blend_amount)) * (1.0f / ((0.5 + ab1_half_blend_amount) - (0.5 - ab1_half_blend_amount))));
		}
		else {
			ab1premix = triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
		result = mix(
			ab0premix,
			ab1premix,
			blend_amount);
	}
	
// STEEP
	else {
		float ab1_noise_sample = texture(ab1_noise, uv).r;
		if (ab1_noise_sample < 0.5 - ab1_half_blend_amount) {
			result = triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
		else if (ab1_noise_sample < 0.5 + ab1_half_blend_amount) {
			result = mix(
				triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).rgb, 
				(ab1_noise_sample - (0.5 - ab1_half_blend_amount)) * (1.0f / ((0.5 + ab1_half_blend_amount) - (0.5 - ab1_half_blend_amount))));
		}
		else {
			result = triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).rgb;
		}
	}
	return result;
}


float process_slope_and_mix_float(float slope, vec2 uv, sampler2D texture0a, sampler2D texture0b, sampler2D texture1a, sampler2D texture1b) {
	float result = 0.0;
	if (slope < steepness - steepness_half_blend_amount) {
		float ab0_noise_sample = texture(ab0_noise, uv).r;
		if (ab0_noise_sample < 0.5 - ab0_half_blend_amount) {
			result = triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).r;
		}
		else if (ab0_noise_sample < 0.5 + ab0_half_blend_amount) {
			result = mix(
				triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).r, 
				triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).r, 
				(ab0_noise_sample - (0.5 - ab0_half_blend_amount)) * (1.0f / ((0.5 + ab0_half_blend_amount) - (0.5 - ab0_half_blend_amount))));
		}
		else {
			result = triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).r;
		}
	}
	
// FLAT-STEEP MIX
	else if (slope < steepness + steepness_half_blend_amount) {
		float blend_amount =  (slope - (steepness - steepness_half_blend_amount)) * (1.0f / ((steepness + steepness_half_blend_amount) - (steepness - steepness_half_blend_amount)));
		float ab0_noise_sample = texture(ab0_noise, uv).r;
		float ab0premix;
		if (ab0_noise_sample < 0.5 - ab0_half_blend_amount) {
			ab0premix = triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).r;
		}
		else if (ab0_noise_sample < 0.5 + ab0_half_blend_amount) {
			ab0premix = mix(
				triplanar_texture(texture0a, texture0a_scale, uv_triplanar_pos, uv_power_normal).r, 
				triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).r, 
				(ab0_noise_sample - (0.5 - ab0_half_blend_amount)) * (1.0f / ((0.5 + ab0_half_blend_amount) - (0.5 - ab0_half_blend_amount))));
		}
		else {
			ab0premix = triplanar_texture(texture0b, texture0b_scale, uv_triplanar_pos, uv_power_normal).r;
		}
		float ab1_noise_sample = texture(ab1_noise, uv).r;
		float ab1premix;
		if (ab1_noise_sample < 0.5 - ab1_half_blend_amount) {
			ab1premix = triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).r;
		}
		else if (ab1_noise_sample < 0.5 + ab1_half_blend_amount) {
			ab1premix = mix(
				triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).r, 
				triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).r, 
				(ab1_noise_sample - (0.5 - ab1_half_blend_amount)) * (1.0f / ((0.5 + ab1_half_blend_amount) - (0.5 - ab1_half_blend_amount))));
		}
		else {
			ab1premix = triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).r;
		}
		result = mix(
			ab0premix,
			ab1premix,
			blend_amount);
	}
	
// STEEP
	else {
		float ab1_noise_sample = texture(ab1_noise, uv).r;
		if (ab1_noise_sample < 0.5 - ab1_half_blend_amount) {
			result = triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).r;
		}
		else if (ab1_noise_sample < 0.5 + ab1_half_blend_amount) {
			result = mix(
				triplanar_texture(texture1a, texture1a_scale, uv_triplanar_pos, uv_power_normal).r, 
				triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).r, 
				(ab1_noise_sample - (0.5 - ab1_half_blend_amount)) * (1.0f / ((0.5 + ab1_half_blend_amount) - (0.5 - ab1_half_blend_amount))));
		}
		else {
			result = triplanar_texture(texture1b, texture1b_scale, uv_triplanar_pos, uv_power_normal).r;
		}
	}
	return result;
}


void fragment() {
	vec3 normal = texture(normalmap, UV).rgb;
	float slope = acos(normal.z);
	
	if (distance_culling()) {
		discard;
	}
	else {
		ALBEDO = process_slope_and_mix_vec3(slope, UV, texture0a_diffuse, texture0b_diffuse, texture1a_diffuse, texture1b_diffuse);
		NORMALMAP = mix(
			texture(normalmap, UV).rgb, 
			process_slope_and_mix_vec3(slope, UV, texture0a_normal, texture0b_normal, texture1a_normal, texture1b_normal), 
			0.5);
		NORMALMAP_DEPTH = 2.0;
		ROUGHNESS = max(
			process_slope_and_mix_float(slope, UV, texture0a_roughness, texture0b_roughness, texture1a_roughness, texture1b_roughness), 
			1.0);
		AO = process_slope_and_mix_float(slope, UV, texture0a_ao, texture0b_ao, texture1a_ao, texture1b_ao);
		AO_LIGHT_AFFECT = 1.0;
	}
}
"
