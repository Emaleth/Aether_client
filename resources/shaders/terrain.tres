[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;


uniform int max_altitude = 1;

uniform float grass_max_slope = 0.55;
uniform float ground_max_slope = 0.6;
uniform float gravel_max_slope = 0.7;

uniform sampler2D heightmap;
uniform sampler2D normalmap;

uniform int rock_scale = 1;
uniform sampler2D rock_diffuse;
uniform sampler2D rock_normal;
uniform sampler2D rock_roughness;
uniform sampler2D rock_ao;

uniform int gravel_scale = 1;
uniform sampler2D gravel_diffuse;
uniform sampler2D gravel_normal;
uniform sampler2D gravel_roughness;
uniform sampler2D gravel_ao;

uniform int ground_scale = 1;
uniform sampler2D ground_diffuse;
uniform sampler2D ground_normal;
uniform sampler2D ground_roughness;
uniform sampler2D ground_ao;

uniform int grass_scale = 1;
uniform sampler2D grass_diffuse;
uniform sampler2D grass_normal;
uniform sampler2D grass_roughness;
uniform sampler2D grass_ao;

uniform sampler2D texture_tile_breaker_noise;


float sum_vec3(vec3 v) {
	return v.x + v.y + v.z;
}

vec3 texture_tile_breaker(sampler2D p_sampler, in vec2 x) {
	float k = texture(texture_tile_breaker_noise, 0.005*x).x; // cheap (cache friendly) lookup
    
	float index = k * 8.0;
	float i = floor(index);
	float f = fract(index);
	
	vec2 offa = sin(vec2(3.0,7.0)*(i+0.0)); // can replace with any other hash
	vec2 offb = sin(vec2(3.0,7.0)*(i+1.0)); // can replace with any other hash
	
	vec3 cola = texture(p_sampler, x + offa).xyz;
	vec3 colb = texture(p_sampler, x + offb).xyz;
    
	return mix(cola, colb, smoothstep(0.2, 0.8, f - 0.1 * sum_vec3(cola-colb)));
}

void vertex() {
	float height = texture(heightmap, UV).r;
	VERTEX.y = height * float(max_altitude);
}


vec3 get_albedo(float slope, vec2 uv) {
	vec3 albedo = vec3(0.0); 
	
	vec3 grass = texture_tile_breaker(grass_diffuse, uv * vec2(float(grass_scale))).rgb;
	vec3 ground = texture_tile_breaker(ground_diffuse, uv * vec2(float(ground_scale))).rgb;
	vec3 gravel = texture_tile_breaker(gravel_diffuse, uv * vec2(float(gravel_scale))).rgb;
	vec3 rock = texture_tile_breaker(rock_diffuse, uv * vec2(float(rock_scale))).rgb;

	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		albedo = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		albedo = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		albedo = mix(gravel, rock, blend_amount);
	} 
	else {
		albedo = rock;
	} 
	
	return albedo.rgb;
}


vec3 get_normal(float slope, vec2 uv) {
	vec3 normal = vec3(0.0); 
	
	vec3 grass = texture_tile_breaker(grass_normal, uv * vec2(float(grass_scale))).rgb;
	vec3 ground = texture_tile_breaker(ground_normal, uv * vec2(float(ground_scale))).rgb;
	vec3 gravel = texture_tile_breaker(gravel_normal, uv * vec2(float(gravel_scale))).rgb;
	vec3 rock = texture_tile_breaker(rock_normal, uv * vec2(float(rock_scale))).rgb;
	
	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		normal = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		normal = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		normal = mix(gravel, rock, blend_amount);
	} 
	else {
		normal = rock;
	} 
 
	return mix(texture(normalmap, uv).rgb, normal, 0.5);
}


float get_roughness(float slope, vec2 uv) {
	float roughness = 0.0;
	
	float grass = texture_tile_breaker(grass_normal, uv * vec2(float(grass_scale))).r;
	float ground = texture_tile_breaker(ground_normal, uv * vec2(float(ground_scale))).r;
	float gravel = texture_tile_breaker(gravel_normal, uv * vec2(float(gravel_scale))).r;
	float rock = texture_tile_breaker(rock_normal, uv * vec2(float(rock_scale))).r;
	
	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		roughness = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		roughness = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		roughness = mix(gravel, rock, blend_amount);
	} 
	else {
		roughness = rock;
	} 

	return max(roughness, 1.0);
}


float get_ao(float slope, vec2 uv) {
	float ao = 0.0;
	
	float grass = texture_tile_breaker(grass_ao, uv * vec2(float(grass_scale))).r;
	float ground = texture_tile_breaker(ground_ao, uv * vec2(float(ground_scale))).r;
	float gravel = texture_tile_breaker(gravel_ao, uv * vec2(float(gravel_scale))).r;
	float rock = texture_tile_breaker(rock_ao, uv * vec2(float(rock_scale))).r;
	
	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		ao = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		ao = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		ao = mix(gravel, rock, blend_amount);
	} 
	else {
		ao = rock;
	} 

	return ao;
}


void fragment() {
	vec3 normal = texture(normalmap, UV).rgb;
	float slope = acos(normal.z);

	ALBEDO = get_albedo(slope, UV);
	NORMALMAP = get_normal(slope, UV);
	NORMALMAP_DEPTH = 2.0;
	ROUGHNESS = get_roughness(slope, UV);
	AO = get_ao(slope, UV);
	AO_LIGHT_AFFECT = 1.0;
}
"
