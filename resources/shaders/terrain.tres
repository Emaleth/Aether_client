[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;


uniform int max_altitude = 1;

uniform float grass_max_slope = 0.55;
uniform float ground_max_slope = 0.6;
uniform float gravel_max_slope = 0.7;

uniform sampler2D heightmap;
uniform sampler2D normalmap;

uniform int rock_scale = 1;
uniform sampler2D rock_diffuse;
uniform sampler2D rock_normal;
uniform sampler2D rock_roughness;
uniform sampler2D rock_ao;

uniform int gravel_scale = 1;
uniform sampler2D gravel_diffuse;
uniform sampler2D gravel_normal;
uniform sampler2D gravel_roughness;
uniform sampler2D gravel_ao;

uniform int ground_scale = 1;
uniform sampler2D ground_diffuse;
uniform sampler2D ground_normal;
uniform sampler2D ground_roughness;
uniform sampler2D ground_ao;

uniform int grass_scale = 1;
uniform sampler2D grass_diffuse;
uniform sampler2D grass_normal;
uniform sampler2D grass_roughness;
uniform sampler2D grass_ao;


void vertex() {
	float height = texture(heightmap, UV).r;
	VERTEX.y = height * float(max_altitude);
}


vec3 get_albedo(float slope, vec2 uv) {
	vec3 albedo = vec3(0.0); 
	
	vec3 grass = texture(grass_diffuse, uv * vec2(float(grass_scale))).rgb;
	vec3 ground = texture(ground_diffuse, uv * vec2(float(ground_scale))).rgb;
	vec3 gravel = texture(gravel_diffuse, uv * vec2(float(gravel_scale))).rgb;
	vec3 rock = texture(rock_diffuse, uv * vec2(float(rock_scale))).rgb;

	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		albedo = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		albedo = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		albedo = mix(gravel, rock, blend_amount);
	} 
	else {
		albedo = rock;
	} 
	
	return albedo.rgb;
}


vec3 get_normal(float slope, vec2 uv) {
	vec3 normal = vec3(0.0); 
	
	vec3 grass = texture(grass_normal, uv * vec2(float(grass_scale))).rgb;
	vec3 ground = texture(ground_normal, uv * vec2(float(ground_scale))).rgb;
	vec3 gravel = texture(gravel_normal, uv * vec2(float(gravel_scale))).rgb;
	vec3 rock = texture(rock_normal, uv * vec2(float(rock_scale))).rgb;
	
	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		normal = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		normal = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		normal = mix(gravel, rock, blend_amount);
	} 
	else {
		normal = rock;
	} 
 
	return mix(texture(normalmap, uv).rgb, normal, 0.5);
}


float get_roughness(float slope, vec2 uv) {
	float roughness = 0.0;
	
	float grass = texture(grass_normal, uv * vec2(float(grass_scale))).r;
	float ground = texture(ground_normal, uv * vec2(float(ground_scale))).r;
	float gravel = texture(gravel_normal, uv * vec2(float(gravel_scale))).r;
	float rock = texture(rock_normal, uv * vec2(float(rock_scale))).r;
	
	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		roughness = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		roughness = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		roughness = mix(gravel, rock, blend_amount);
	} 
	else {
		roughness = rock;
	} 

	return max(roughness, 1.0);
}


float get_ao(float slope, vec2 uv) {
	float ao = 0.0;
	
	float grass = texture(grass_ao, uv * vec2(float(grass_scale))).r;
	float ground = texture(ground_ao, uv * vec2(float(ground_scale))).r;
	float gravel = texture(gravel_ao, uv * vec2(float(gravel_scale))).r;
	float rock = texture(rock_ao, uv * vec2(float(rock_scale))).r;
	
	if (slope <= grass_max_slope) {
		float blend_amount = slope / grass_max_slope;
		ao = mix(grass, ground, blend_amount);
	} 
	else if (slope <= ground_max_slope) {
		float blend_amount = (slope - grass_max_slope) * (1.0f / (ground_max_slope - grass_max_slope));
		ao = mix(ground, gravel, blend_amount);
	} 
	else if (slope <= gravel_max_slope) {
		float blend_amount = (slope - ground_max_slope) * (1.0f / (gravel_max_slope - ground_max_slope));
		ao = mix(gravel, rock, blend_amount);
	} 
	else {
		ao = rock;
	} 

	return ao;
}


void fragment() {
	vec3 normal = texture(normalmap, UV).rgb;
	float slope = acos(normal.z);

	ALBEDO = get_albedo(slope, UV);
	NORMALMAP = get_normal(slope, UV);
	NORMALMAP_DEPTH = 2.0;
	ROUGHNESS = get_roughness(slope, UV);
	AO = get_ao(slope, UV);
	AO_LIGHT_AFFECT = 1.0;
}
"
